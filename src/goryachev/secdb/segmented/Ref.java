// Copyright Â© 2019-2020 Andy Goryachev <andy@goryachev.com>
package goryachev.secdb.segmented;
import goryachev.common.io.DReader;
import goryachev.common.io.DWriter;
import goryachev.common.util.CKit;
import goryachev.common.util.FH;
import goryachev.common.util.Hex;
import goryachev.common.util.Parsers;
import goryachev.common.util.SB;
import goryachev.secdb.IRef;


/**
 * SecDB Stored Object Reference.
 */
public abstract class Ref
	implements IRef
{
	public abstract boolean isSingleSegment();
	
	public abstract int getSegmentCount();
	
	/** returns the only segment name.  throws an Error if not isSingleSegment() */
	public abstract String getSegment();
	
	/** returns start offset in the only segment.  throws an Error if not isSingleSegment() */
	public abstract long getOffset();
	
	/** returns the specified segment name */
	public abstract String getSegment(int ix);
	
	/** returns the specified start offset */
	public abstract long getOffset(int ix);
	
	/** appends a segment.  returns a new instance of Ref.Multiple */
	public abstract Ref.MultiSegment addSegment(String segment, long offset);
	
	/** used to persist the reference.  the resulting string can be parsed by Ref.parse() */
	public abstract String toPersistentString();
	
	public abstract void write(DWriter wr) throws Exception;
	
	//
	
	protected static final String MULTIPLE = "M";
	protected static final char SEP = '.';
	protected final long length;
	protected final byte[] dataKey;


	protected Ref(long length, byte[] dataKey)
	{
		this.length = length;
		this.dataKey = dataKey;
	}
	
	
	/** returns a new Ref from a string representation generated by toPersistentString() */
	public static Ref parse(String text) throws Exception
	{
		if(text == null)
		{
			return null;
		}
		
		if(text.startsWith(MULTIPLE))
		{
			// multi-segment Ref
			return MultiSegment.parseMultiSegment(text);
		}
		else
		{
			// single segment Ref
			return SingleSegment.parseSingleSegment(text);
		}
	}
	

	public static Ref read(DReader rd) throws Exception
	{
		int sz = rd.readShort();
		if(sz <= 0)
		{
			throw new Exception("invalid segment count: " + sz);
		}

		long len = rd.readLong();
		byte[] dataKey = rd.readByteArray(512);

		if(sz == 1)
		{
			String segment = rd.readString();
			long offset = rd.readLong();
			return new SingleSegment(len, dataKey, segment, offset);
		}
		else
		{
			String[] segments = new String[sz];
			long[] offsets = new long[sz];
			
			for(int i=0; i<sz; i++)
			{
				segments[i] = rd.readString();
				offsets[i] = rd.readLong();
			}
			
			return new MultiSegment(len, dataKey, segments, offsets);
		}
	}
	
	
	public long getLength()
	{
		return length;
	}
	
	
	public byte[] getDataKey()
	{
		return dataKey;
	}

	
	//
	
	
	/** single-segment reference */
	public static class SingleSegment extends Ref
	{
		private final String segment;
		private final long offset;

		
		public SingleSegment(long length, byte[] dataKey, String segment, long offset)
		{
			super(length, dataKey);
			this.segment = segment;
			this.offset = offset;
		}
		
		
		protected static SingleSegment parseSingleSegment(String text) throws Exception
		{
			String[] ss = CKit.split(text, SEP);
			if(ss.length != 4)
			{
				throw new Exception("not a Ref: " + text);
			}

			long len = Parsers.parseLong(ss[0], -1);
			if(len < 0)
			{
				throw new Exception("negative length: " + text);
			}
			
			byte[] key = Parsers.parseByteArray(ss[1]);
			String seg = ss[2];
			long off = Long.parseLong(ss[3]);
			return new SingleSegment(len, key, seg, off);
		}

		
		public String toPersistentString()
		{
			SB sb = new SB();
			sb.a(length);
			sb.a(SEP);
			if(dataKey != null)
			{
				sb.a(Hex.toHexString(dataKey));
			}
			sb.a(SEP);
			sb.a(segment);
			sb.a(SEP);
			sb.a(offset);
			return sb.toString();
		}
		
		
		public void write(DWriter wr) throws Exception
		{
			wr.writeShort(1);
			wr.writeLong(length);
			wr.writeByteArray(dataKey);
			wr.writeString(segment);
			wr.writeLong(offset);
		}
		

		public boolean isSingleSegment()
		{
			return true;
		}
		
		
		public int getSegmentCount()
		{
			return 1;
		}
		
		
		public String getSegment()
		{
			return segment;
		}
		
		
		public long getOffset()
		{
			return offset;
		}
		
		
		public String getSegment(int ix)
		{
			if(ix == 0)
			{
				return segment;
			}
			throw new Error();
		}


		public long getOffset(int ix)
		{
			if(ix == 0)
			{
				return offset;
			}
			throw new Error();
		}
		
		
		public int hashCode()
		{
			int h = FH.hash(SingleSegment.class);
			h = FH.hash(h, segment);
			h = FH.hash(h, offset);
			return FH.hash(h, length);
		}
		
		
		public boolean equals(Object x)
		{
			if(x == this)
			{
				return true;
			}
			else if(x instanceof SingleSegment)
			{
				SingleSegment r = (SingleSegment)x;
				return
					(offset == r.offset) &&
					(length == r.length) &&
					CKit.equals(segment, r.segment);
			}
			else
			{
				return false;
			}
		}
		

		public Ref.MultiSegment addSegment(String segment, long offset)
		{
			// TODO append a segment
			throw new Error();
		}
		
		
		public String toString()
		{
			return "Ref[" + length + ":" + segment + ":" + Hex.toHexString(offset) + "]";
		}
	}
	
	
	//
	
	
	/** multi-segment reference */
	public static class MultiSegment extends Ref
	{
		private final String[] segments;
		private final long[] offsets;
		
		
		public MultiSegment(long length, byte[] dataKey, String[] segments, long[] offsets)
		{
			super(length, dataKey);
			
			this.segments = segments;
			this.offsets = offsets;
		}
		
		
		protected static MultiSegment parseMultiSegment(String text) throws Exception
		{
			String[] ss = CKit.split(text, SEP);
			int ix = 0;
			
			if(!MULTIPLE.equals(ss[ix++]))
			{
				throw new Exception("not a Ref.Multiple: " + text);
			}
			
			int sz = Parsers.parseInt(ss[ix++], -1);
			if(sz <= 1)
			{
				throw new Exception("not a Ref.Multiple: " + text);
			}
			
			long len = Parsers.parseLong(ss[ix++], -1);
			if(len < 0)
			{
				throw new Exception("negative length: " + text);
			}
			
			byte[] key = Parsers.parseByteArray(ss[ix++]);
			
			String[] segments = new String[sz];
			long[] offsets = new long[sz];
			
			for(int i=0; i<sz; i++)
			{
				segments[i] = ss[ix++];
				offsets[i] = Parsers.parseLong(ss[ix++]);
			}

			return new MultiSegment(len, key, segments, offsets);
		}


		public String toPersistentString()
		{
			int sz = getSegmentCount();

			SB sb = new SB();
			sb.a(MULTIPLE);
			sb.a(SEP);
			sb.a(sz);
			sb.a(SEP);
			sb.a(length);
			sb.a(SEP);
			if(dataKey != null)
			{
				sb.a(Hex.toHexString(dataKey));
			}
			sb.a(SEP);
			
			for(int i=0; i<sz; i++)
			{
				sb.a(getSegment(i));
				sb.a(SEP);
				sb.a(getOffset(i));
				sb.a(SEP);
			}
			return sb.toString();
		}
		

		public void write(DWriter wr) throws Exception
		{
			int sz = getSegmentCount();
			wr.writeShort(sz);
			wr.writeLong(length);
			wr.writeByteArray(dataKey);
			
			for(int i=0; i<sz; i++)
			{
				wr.writeString(getSegment(i));
				wr.writeLong(getOffset(i));
			}
		}
		
		
		public boolean isSingleSegment()
		{
			return false;
		}

		
		public int getSegmentCount()
		{
			return segments.length;
		}
		
		
		public String getSegment()
		{
			throw new Error();
		}


		public long getOffset()
		{
			throw new Error();
		}
		
		
		public String getSegment(int ix)
		{
			return segments[ix];
		}


		public long getOffset(int ix)
		{
			return offsets[ix];
		}
		
		
		public int hashCode()
		{
			int h = FH.hash(SingleSegment.class);
			h = FH.hash(h, segments);
			h = FH.hash(h, offsets);
			return FH.hash(h, length);
		}
		
		
		public boolean equals(Object x)
		{
			if(x == this)
			{
				return true;
			}
			else if(x instanceof MultiSegment)
			{
				MultiSegment r = (MultiSegment)x;
				return
					(length == r.length) &&
					CKit.equals(offsets, r.offsets) &&
					CKit.equals(segments, r.segments);
			}
			else
			{
				return false;
			}
		}
		
		
		public Ref.MultiSegment addSegment(String segment, long offset)
		{
			// TODO append a segment
			throw new Error();
		}

		
		public String toString()
		{
			SB sb = new SB();
			sb.a("Ref[len=");
			sb.a(length);
			
			for(int i=0; i<getSegmentCount(); i++)
			{
				sb.a(",");
				sb.a(getSegment(i));
				sb.a(":");
				sb.a(Hex.toHexString(getOffset(i)));
			}
			
			sb.a("]");
			return sb.toString();
		}
	}
}
